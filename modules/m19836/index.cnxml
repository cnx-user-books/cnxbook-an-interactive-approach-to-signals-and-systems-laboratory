<document xmlns="http://cnx.rice.edu/cnxml" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:md="http://cnx.rice.edu/mdml">
  <title>Analysis of Analog and Digital Systems</title>
  <metadata>
  <md:content-id>m19836</md:content-id><md:title>Analysis of Analog and Digital Systems</md:title>
  <md:abstract/>
  <md:uuid>19be0e5e-1055-40a5-b449-6243c861cdcc</md:uuid>
</metadata>

<content>
    
    
    <para id="id43871146">In the previous labs, different mathematical transformation tools to represent analog and discrete signals were examined. This final lab builds on the knowledge gained in the previous labs to show how to use these tools to perform signal processing. </para>
    <section id="id43871166">
      <title>Analog Filtering</title>
      <para id="id43871180">Analog filters are defined over a continuous range of frequencies. Four basic kinds of analog filters are lowpass, highpass, bandpass and bandstop. <link target-id="id43871209"/> shows the ideal characteristics of these filters. In the noise removal example of Lab 5 , an ideal lowpass filter was used to remove high-frequency noise. However, the ideal characteristics are not physically realizable and actual filters can only approximate the ideal characteristics. The RC series circuit analyzed in Lab 3 and Lab 4 is a simple example of an analog lowpass filter. </para>
      
      <para id="id43871203">
        <figure id="id43871209"><media id="id8554910" alt=""><image src="../../media/graphics14-f703.png" mime-type="image/png" height="429" width="532"/></media><caption>Characteristics of Ideal Filters (a) Lowpass, (b) Highpass, (c) Bandpass, (d) Bandstop</caption></figure>
      </para>
      
      <para id="id43871239">The voltage output for the circuit shown in <link target-id="id43871421"/> is given by <link target-id="Ref6" document="m31521"/>:</para>
      
      <equation id="eip-85"><m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mrow><m:msub><m:mi>V</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mstyle fontstyle="italic"><m:mrow><m:mtext>out</m:mtext></m:mrow></m:mstyle></m:mrow></m:mstyle></m:msub><m:mo stretchy="false">=</m:mo><m:mfrac><m:mrow><m:mrow><m:mn>1</m:mn><m:mo stretchy="false">/</m:mo><m:mo stretchy="false">(</m:mo></m:mrow><m:mi fontstyle="italic">jωC</m:mi><m:mo stretchy="false">)</m:mo></m:mrow><m:mrow><m:mrow><m:mi>R</m:mi><m:mo stretchy="false">+</m:mo><m:mrow><m:mn>1</m:mn><m:mo stretchy="false">/</m:mo><m:mo stretchy="false">(</m:mo></m:mrow></m:mrow><m:mi fontstyle="italic">jωC</m:mi><m:mo stretchy="false">)</m:mo></m:mrow></m:mfrac></m:mrow><m:msub><m:mi>V</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mstyle fontstyle="italic"><m:mrow><m:mtext>in</m:mtext></m:mrow></m:mstyle></m:mrow></m:mstyle></m:msub></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{V rSub { size 8{ ital "out"} } = {  {1/ \( jωC \) }  over  {R+1/ \( jωC \) } } V rSub { size 8{ ital "in"} } } {}</m:annotation></m:semantics></m:math>  </equation><figure id="id43871421"><media id="id8477772" alt=""><image src="../../media/graphics15-8716.png" mime-type="image/png" height="104" width="246"/></media><caption>RC Series Circuit Used as Analog Lowpass Filter</caption></figure>
      
      <para id="id43871453">The magnitude and phase response can be easily found to be <link target-id="Ref6" document="m31521"/>:</para>
      
      <equation id="eip-159"><m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mrow><m:mrow><m:mo stretchy="false">∣</m:mo><m:mrow><m:mi>H</m:mi><m:mo stretchy="false">(</m:mo><m:mi>ω</m:mi><m:mo stretchy="false">)</m:mo></m:mrow><m:mo stretchy="false">∣</m:mo></m:mrow><m:mo stretchy="false">=</m:mo><m:mrow><m:mo stretchy="false">∣</m:mo><m:mfrac><m:msub><m:mi>V</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mstyle fontstyle="italic"><m:mrow><m:mtext>out</m:mtext></m:mrow></m:mstyle></m:mrow></m:mstyle></m:msub><m:msub><m:mi>V</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mstyle fontstyle="italic"><m:mrow><m:mtext>in</m:mtext></m:mrow></m:mstyle></m:mrow></m:mstyle></m:msub></m:mfrac><m:mo stretchy="false">∣</m:mo></m:mrow></m:mrow><m:mo stretchy="false">=</m:mo><m:mfrac><m:mn>1</m:mn><m:msqrt><m:mrow><m:mrow><m:mn>1</m:mn><m:mo stretchy="false">+</m:mo><m:msup><m:mi>ω</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mn>2</m:mn></m:mrow></m:mstyle></m:msup></m:mrow><m:msup><m:mi>R</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mn>2</m:mn></m:mrow></m:mstyle></m:msup><m:msup><m:mi>C</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mn>2</m:mn></m:mrow></m:mstyle></m:msup></m:mrow></m:msqrt></m:mfrac></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{ lline H \( ω \)  rline = lline  {  {V rSub { size 8{ ital "out"} } }  over  {V rSub { size 8{ ital "in"} } } }  rline = {  {1}  over  { sqrt {1+ω rSup { size 8{2} } R rSup { size 8{2} } C rSup { size 8{2} } } } } } {}</m:annotation></m:semantics></m:math></equation>
      <equation id="eip-543"><m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>∠</m:mi><m:mi>H</m:mi><m:mo stretchy="false">(</m:mo><m:mi>ω</m:mi><m:mrow><m:mo stretchy="false">)</m:mo><m:mo stretchy="false">=</m:mo><m:mtext>arg</m:mtext></m:mrow><m:mrow><m:mfenced open="(" close=")"><m:mfrac><m:msub><m:mi>V</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mstyle fontstyle="italic"><m:mrow><m:mtext>out</m:mtext></m:mrow></m:mstyle></m:mrow></m:mstyle></m:msub><m:msub><m:mi>V</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mstyle fontstyle="italic"><m:mrow><m:mtext>in</m:mtext></m:mrow></m:mstyle></m:mrow></m:mstyle></m:msub></m:mfrac></m:mfenced><m:mo stretchy="false">=</m:mo><m:mrow><m:mo stretchy="false">−</m:mo><m:msup><m:mtext>tan</m:mtext><m:mstyle fontsize="8pt"><m:mrow><m:mrow><m:mo stretchy="false">−</m:mo><m:mn>1</m:mn></m:mrow></m:mrow></m:mstyle></m:msup></m:mrow></m:mrow><m:mo stretchy="false">(</m:mo><m:mi>ω</m:mi><m:mstyle fontstyle="italic"><m:mrow><m:mtext>RC</m:mtext></m:mrow></m:mstyle><m:mo stretchy="false">)</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{∠H \( ω \) ="arg" left ( {  {V rSub { size 8{ ital "out"} } }  over  {V rSub { size 8{ ital "in"} } } }  right )= - "tan" rSup { size 8{ - 1} }  \( ω ital "RC" \) } {}</m:annotation></m:semantics></m:math>  </equation><para id="id43871850"> If the positions of R and C are interchanged, a simple analog highpass filter is obtained as shown in <link target-id="id43871860"/>.</para>
      <figure id="id43871860"><media id="id8489828" alt=""><image src="../../media/graphics16-5f01.png" mime-type="image/png" height="124" width="249"/></media><caption>RC Series Circuit Used as Analog Highpass Filter</caption></figure>
      
      <para id="id43871889">The voltage output for this circuit is given by </para>
      
      <equation id="eip-875"><m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mrow><m:msub><m:mi>V</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mstyle fontstyle="italic"><m:mrow><m:mtext>out</m:mtext></m:mrow></m:mstyle></m:mrow></m:mstyle></m:msub><m:mo stretchy="false">=</m:mo><m:mfrac><m:mi>R</m:mi><m:mrow><m:mrow><m:mi>R</m:mi><m:mo stretchy="false">+</m:mo><m:mrow><m:mn>1</m:mn><m:mo stretchy="false">/</m:mo><m:mo stretchy="false">(</m:mo></m:mrow></m:mrow><m:mi fontstyle="italic">jωC</m:mi><m:mo stretchy="false">)</m:mo></m:mrow></m:mfrac></m:mrow><m:msub><m:mi>V</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mstyle fontstyle="italic"><m:mrow><m:mtext>in</m:mtext></m:mrow></m:mstyle></m:mrow></m:mstyle></m:msub></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{V rSub { size 8{ ital "out"} } = {  {R}  over  {R+1/ \( jωC \) } } V rSub { size 8{ ital "in"} } } {}</m:annotation></m:semantics></m:math>  </equation><para id="id43872039">The corresponding magnitude and phase responses are </para>
      
      <equation id="eip-50"><m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mrow><m:mrow><m:mo stretchy="false">∣</m:mo><m:mrow><m:mi>H</m:mi><m:mo stretchy="false">(</m:mo><m:mi>ω</m:mi><m:mo stretchy="false">)</m:mo></m:mrow><m:mo stretchy="false">∣</m:mo></m:mrow><m:mo stretchy="false">=</m:mo><m:mrow><m:mo stretchy="false">∣</m:mo><m:mfrac><m:msub><m:mi>V</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mstyle fontstyle="italic"><m:mrow><m:mtext>out</m:mtext></m:mrow></m:mstyle></m:mrow></m:mstyle></m:msub><m:msub><m:mi>V</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mstyle fontstyle="italic"><m:mrow><m:mtext>in</m:mtext></m:mrow></m:mstyle></m:mrow></m:mstyle></m:msub></m:mfrac><m:mo stretchy="false">∣</m:mo></m:mrow></m:mrow><m:mo stretchy="false">=</m:mo><m:mfrac><m:mn>1</m:mn><m:msqrt><m:mrow><m:mrow><m:mn>1</m:mn><m:mo stretchy="false">+</m:mo><m:mrow><m:mn>1</m:mn><m:mo stretchy="false">/</m:mo><m:mo stretchy="false">(</m:mo></m:mrow></m:mrow><m:msup><m:mi>ω</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mn>2</m:mn></m:mrow></m:mstyle></m:msup><m:msup><m:mi>R</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mn>2</m:mn></m:mrow></m:mstyle></m:msup><m:msup><m:mi>C</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mn>2</m:mn></m:mrow></m:mstyle></m:msup><m:mo stretchy="false">)</m:mo></m:mrow></m:msqrt></m:mfrac></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{ lline H \( ω \)  rline = lline  {  {V rSub { size 8{ ital "out"} } }  over  {V rSub { size 8{ ital "in"} } } }  rline = {  {1}  over  { sqrt {1+1/ \( ω rSup { size 8{2} } R rSup { size 8{2} } C rSup { size 8{2} }  \) } } } } {}</m:annotation></m:semantics></m:math> </equation><equation id="eip-527"><m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>∠</m:mi><m:mi>H</m:mi><m:mo stretchy="false">(</m:mo><m:mi>ω</m:mi><m:mrow><m:mo stretchy="false">)</m:mo><m:mo stretchy="false">=</m:mo><m:mtext>arg</m:mtext></m:mrow><m:mrow><m:mfenced open="(" close=")"><m:mfrac><m:msub><m:mi>V</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mstyle fontstyle="italic"><m:mrow><m:mtext>out</m:mtext></m:mrow></m:mstyle></m:mrow></m:mstyle></m:msub><m:msub><m:mi>V</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mstyle fontstyle="italic"><m:mrow><m:mtext>in</m:mtext></m:mrow></m:mstyle></m:mrow></m:mstyle></m:msub></m:mfrac></m:mfenced><m:mo stretchy="false">=</m:mo><m:msup><m:mtext>tan</m:mtext><m:mstyle fontsize="8pt"><m:mrow><m:mrow><m:mo stretchy="false">−</m:mo><m:mn>1</m:mn></m:mrow></m:mrow></m:mstyle></m:msup></m:mrow><m:mfenced open="(" close=")"><m:mfrac><m:mn>1</m:mn><m:mrow><m:mi>ω</m:mi><m:mstyle fontstyle="italic"><m:mrow><m:mtext>RC</m:mtext></m:mrow></m:mstyle></m:mrow></m:mfrac></m:mfenced></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{∠H \( ω \) ="arg" left ( {  {V rSub { size 8{ ital "out"} } }  over  {V rSub { size 8{ ital "in"} } } }  right )="tan" rSup { size 8{ - 1} }  left ( {  {1}  over  {ω ital "RC"} }  right )} {}</m:annotation></m:semantics></m:math></equation>
      
    </section>
    <section id="id44216226">
 
      <title>Digital Filtering</title>
      <para id="id44216243">Digital signal filtering is a fundamental concept in digital signal processing. Two basic kinds of digital filters that are widely used are FIR and IIR:</para>
      <para id="id44216250">FIR (finite impulse response) – filters having finite unit sample responses </para>
      <para id="id44216257">IIR (infinite impulse response) – filters having infinite unit sample responses</para>
      <para id="id44216264">Unit sample response denotes the output in response to a unit input signal. It is common to express digital filters in the form of difference equations. In this form, an FIR filter is expressed as</para>
      
      <equation id="eip-715"><m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>y</m:mi><m:mo stretchy="false">[</m:mo><m:mi>n</m:mi><m:mrow><m:mo stretchy="false">]</m:mo><m:mo stretchy="false">=</m:mo><m:mrow><m:munderover><m:mo stretchy="false">∑</m:mo><m:mstyle fontsize="8pt"><m:mrow><m:mrow><m:mi>k</m:mi><m:mo stretchy="false">=</m:mo><m:mn>0</m:mn></m:mrow></m:mrow></m:mstyle><m:mstyle fontsize="8pt"><m:mrow><m:mi>N</m:mi></m:mrow></m:mstyle></m:munderover><m:mrow><m:msub><m:mi>b</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mi>k</m:mi></m:mrow></m:mstyle></m:msub><m:mi>x</m:mi><m:mo stretchy="false">[</m:mo><m:mrow><m:mi>n</m:mi><m:mo stretchy="false">−</m:mo><m:mi>k</m:mi></m:mrow><m:mo stretchy="false">]</m:mo></m:mrow></m:mrow></m:mrow></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{y \[ n \] = Sum cSub { size 8{k=0} }  cSup { size 8{N} }  {b rSub { size 8{k} } x \[ n - k \] } } {}</m:annotation></m:semantics></m:math> </equation><para id="id44216448">where 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mi>b</m:mi></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{b} {}</m:annotation></m:semantics></m:math>’s denote the filter coefficients and <!--Sorry, this media type is not supported.--> the filter order. As described by this equation, an FIR filter uses a current input 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>x</m:mi><m:mo stretchy="false">[</m:mo><m:mi>n</m:mi><m:mo stretchy="false">]</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{x \[ n \] } {}</m:annotation></m:semantics></m:math> and a number of previous inputs 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>x</m:mi><m:mo stretchy="false">[</m:mo><m:mrow><m:mi>n</m:mi><m:mo stretchy="false">−</m:mo><m:mi>k</m:mi></m:mrow><m:mo stretchy="false">]</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{x \[ n - k \] } {}</m:annotation></m:semantics></m:math> to generate a current output
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>y</m:mi><m:mo stretchy="false">[</m:mo><m:mi>n</m:mi><m:mo stretchy="false">]</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{y \[ n \] } {}</m:annotation></m:semantics></m:math>. </para>
      <para id="id44216783">The difference equation of an IIR filter is given by</para>
      
      <equation id="eip-641"><m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>y</m:mi><m:mo stretchy="false">[</m:mo><m:mi>n</m:mi><m:mrow><m:mo stretchy="false">]</m:mo><m:mo stretchy="false">=</m:mo><m:mrow><m:mrow><m:munderover><m:mo stretchy="false">∑</m:mo><m:mstyle fontsize="8pt"><m:mrow><m:mrow><m:mi>k</m:mi><m:mo stretchy="false">=</m:mo><m:mn>0</m:mn></m:mrow></m:mrow></m:mstyle><m:mstyle fontsize="8pt"><m:mrow><m:mi>N</m:mi></m:mrow></m:mstyle></m:munderover><m:mrow><m:msub><m:mi>b</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mi>k</m:mi></m:mrow></m:mstyle></m:msub><m:mi>x</m:mi><m:mo stretchy="false">[</m:mo><m:mrow><m:mi>n</m:mi><m:mo stretchy="false">−</m:mo><m:mi>k</m:mi></m:mrow><m:mo stretchy="false">]</m:mo></m:mrow></m:mrow><m:mo stretchy="false">−</m:mo><m:mrow><m:munderover><m:mo stretchy="false">∑</m:mo><m:mstyle fontsize="8pt"><m:mrow><m:mrow><m:mi>k</m:mi><m:mo stretchy="false">=</m:mo><m:mn>1</m:mn></m:mrow></m:mrow></m:mstyle><m:mstyle fontsize="8pt"><m:mrow><m:mi>M</m:mi></m:mrow></m:mstyle></m:munderover><m:mrow><m:msub><m:mi>a</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mi>k</m:mi></m:mrow></m:mstyle></m:msub><m:mi>y</m:mi><m:mo stretchy="false">[</m:mo><m:mrow><m:mi>n</m:mi><m:mo stretchy="false">−</m:mo><m:mi>k</m:mi></m:mrow><m:mo stretchy="false">]</m:mo></m:mrow></m:mrow></m:mrow></m:mrow></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{y \[ n \] = Sum cSub { size 8{k=0} }  cSup { size 8{N} }  {b rSub { size 8{k} } x \[ n - k \] }  -  Sum cSub { size 8{k=1} }  cSup { size 8{M} }  {a rSub { size 8{k} } y \[ n - k \] } } {}</m:annotation></m:semantics></m:math>  </equation><para id="id44217050">where 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mi>b</m:mi></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{b} {}</m:annotation></m:semantics></m:math>’s and 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mi>a</m:mi></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{a} {}</m:annotation></m:semantics></m:math>’s denote the filter coefficients and <m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mi>N</m:mi></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{b} {}</m:annotation></m:semantics></m:math> and <m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mi>M</m:mi></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{b} {}</m:annotation></m:semantics></m:math> the number of zeros and poles, respectively. As indicated by Equation (8), an IIR filter uses a number of previous outputs 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>y</m:mi><m:mo stretchy="false">[</m:mo><m:mrow><m:mi>n</m:mi><m:mo stretchy="false">−</m:mo><m:mi>k</m:mi></m:mrow><m:mo stretchy="false">]</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{y \[ n - k \] } {}</m:annotation></m:semantics></m:math> as well as a current and a number of previous inputs to generate a current output 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>y</m:mi><m:mo stretchy="false">[</m:mo><m:mi>n</m:mi><m:mo stretchy="false">]</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{y \[ n \] } {}</m:annotation></m:semantics></m:math>.</para>
      <para id="id44217380">In general, as compared to IIR filters, FIR filters require less precision and are computationally more stable. Table 1 lists some of the differences between FIR and IIR filters. For the theoretical details on these differences, refer to <link target-id="Ref18" document="m31521"/>.</para>
      <table id="id44217403" summary="FIR Filter Attributes versus IIR Filter Attributes">
<tgroup cols="3"><colspec colnum="1" colname="c1"/>
	<colspec colnum="2" colname="c2"/>
	<colspec colnum="3" colname="c3"/>
	<tbody>
		<row>
			<entry>
				<term>Attribute</term>
			</entry>
			<entry>
				<term>FIR filter</term>
			</entry>
			<entry>
				<term>IIR filter</term>
			</entry>
		</row>
		<row>
			<entry>Stability</entry>
			<entry>Always stable</entry>
			<entry>Conditionally stable</entry>
		</row>
		<row>
			<entry>Computational complexity</entry>
			<entry>More operations</entry>
			<entry>Fewer operations</entry>
		</row>
		<row>
			<entry>Precision </entry>
			<entry>Less coefficient precision required</entry>
			<entry>Higher coefficient precision required</entry>
		</row>
	</tbody>

</tgroup><caption>FIR Filter Attributes versus IIR Filter Attributes</caption>
</table>
      
      <para id="id44217051">where 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mi>b</m:mi></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{b} {}</m:annotation></m:semantics></m:math>’s and 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mi>a</m:mi></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{a} {}</m:annotation></m:semantics></m:math>’s denote the filter coefficients and <!--Sorry, this media type is not supported.--> and <!--Sorry, this media type is not supported.--> the number of zeros and poles, respectively. As indicated by Equation (8), an IIR filter uses a number of previous outputs 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>y</m:mi><m:mo stretchy="false">[</m:mo><m:mrow><m:mi>n</m:mi><m:mo stretchy="false">−</m:mo><m:mi>k</m:mi></m:mrow><m:mo stretchy="false">]</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{y \[ n - k \] } {}</m:annotation></m:semantics></m:math> as well as a current and a number of previous inputs to generate a current output 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>y</m:mi><m:mo stretchy="false">[</m:mo><m:mi>n</m:mi><m:mo stretchy="false">]</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{y \[ n \] } {}</m:annotation></m:semantics></m:math>.</para>
      
      <equation id="eip-860"><m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>H</m:mi><m:mo stretchy="false">(</m:mo><m:mi>ω</m:mi><m:mrow><m:mo stretchy="false">)</m:mo><m:mo stretchy="false">=</m:mo><m:mfrac><m:mrow><m:mrow><m:msub><m:mi>b</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mn>0</m:mn></m:mrow></m:mstyle></m:msub><m:mo stretchy="false">+</m:mo><m:msub><m:mi>b</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mn>1</m:mn></m:mrow></m:mstyle></m:msub></m:mrow><m:mrow><m:msup><m:mi>e</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mrow><m:mo stretchy="false">−</m:mo><m:mi fontstyle="italic">jω</m:mi></m:mrow></m:mrow></m:mstyle></m:msup><m:mo stretchy="false">+</m:mo><m:mtext>.</m:mtext></m:mrow><m:mtext>.</m:mtext><m:mrow><m:mtext>.</m:mtext><m:mo stretchy="false">+</m:mo><m:msub><m:mi>b</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mi>N</m:mi></m:mrow></m:mstyle></m:msub></m:mrow><m:msup><m:mi>e</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mrow><m:mrow><m:mo stretchy="false">−</m:mo><m:mstyle fontstyle="italic"><m:mrow><m:mtext>jN</m:mtext></m:mrow></m:mstyle></m:mrow><m:mi>ω</m:mi></m:mrow></m:mrow></m:mstyle></m:msup></m:mrow><m:mrow><m:mrow><m:mn>1</m:mn><m:mo stretchy="false">+</m:mo><m:msub><m:mi>a</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mn>1</m:mn></m:mrow></m:mstyle></m:msub></m:mrow><m:mrow><m:msup><m:mi>e</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mrow><m:mo stretchy="false">−</m:mo><m:mi fontstyle="italic">jω</m:mi></m:mrow></m:mrow></m:mstyle></m:msup><m:mo stretchy="false">+</m:mo><m:mtext>.</m:mtext></m:mrow><m:mtext>.</m:mtext><m:mrow><m:mtext>.</m:mtext><m:mo stretchy="false">+</m:mo><m:msub><m:mi>a</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mi>M</m:mi></m:mrow></m:mstyle></m:msub></m:mrow><m:msup><m:mi>e</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mrow><m:mrow><m:mo stretchy="false">−</m:mo><m:mstyle fontstyle="italic"><m:mrow><m:mtext>jM</m:mtext></m:mrow></m:mstyle></m:mrow><m:mi>ω</m:mi></m:mrow></m:mrow></m:mstyle></m:msup></m:mrow></m:mfrac></m:mrow></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{H \( ω \) = {  {b rSub { size 8{0} } +b rSub { size 8{1} } e rSup { size 8{ - jω} } + "."  "."  "." +b rSub { size 8{N} } e rSup { size 8{ -  ital "jN"ω} } }  over  {1+a rSub { size 8{1} } e rSup { size 8{ - jω} } + "."  "."  "." +a rSub { size 8{M} } e rSup { size 8{ -  ital "jM"ω} } } } } {}</m:annotation></m:semantics></m:math> </equation><para id="id44217966">It is well-known that a direct-form implementation expressed by Equation (9) is sensitive, in terms of stability, to coefficient quantization errors. Noting that the second-order cascade form produces a more response that is more resistant to quantization noise <link target-id="Ref19" document="m31521"/>, the above transfer function is often written and implemented as follows: </para>
      
      <equation id="eip-92"><m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>H</m:mi><m:mo stretchy="false">(</m:mo><m:mi>ω</m:mi><m:mrow><m:mo stretchy="false">)</m:mo><m:mo stretchy="false">=</m:mo><m:mrow><m:munderover><m:mo stretchy="false">∏</m:mo><m:mstyle fontsize="8pt"><m:mrow><m:mrow><m:mi>k</m:mi><m:mo stretchy="false">=</m:mo><m:mn>1</m:mn></m:mrow></m:mrow></m:mstyle><m:mstyle fontsize="8pt"><m:mrow><m:msub><m:mi>N</m:mi><m:mstyle fontsize="6pt"><m:mrow><m:mi>s</m:mi></m:mrow></m:mstyle></m:msub></m:mrow></m:mstyle></m:munderover><m:mfrac><m:mrow><m:mrow><m:msub><m:mi>b</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mn>0k</m:mn></m:mrow></m:mstyle></m:msub><m:mo stretchy="false">+</m:mo><m:msub><m:mi>b</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mn>1k</m:mn></m:mrow></m:mstyle></m:msub></m:mrow><m:mrow><m:msup><m:mi>e</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mrow><m:mo stretchy="false">−</m:mo><m:mi fontstyle="italic">jω</m:mi></m:mrow></m:mrow></m:mstyle></m:msup><m:mo stretchy="false">+</m:mo><m:msub><m:mi>b</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mn>2k</m:mn></m:mrow></m:mstyle></m:msub></m:mrow><m:msup><m:mi>e</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mrow><m:mo stretchy="false">−</m:mo><m:mi fontstyle="italic">j2ω</m:mi></m:mrow></m:mrow></m:mstyle></m:msup></m:mrow><m:mrow><m:mrow><m:mn>1</m:mn><m:mo stretchy="false">+</m:mo><m:msub><m:mi>a</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mn>1k</m:mn></m:mrow></m:mstyle></m:msub></m:mrow><m:mrow><m:msup><m:mi>e</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mrow><m:mo stretchy="false">−</m:mo><m:mi fontstyle="italic">jω</m:mi></m:mrow></m:mrow></m:mstyle></m:msup><m:mo stretchy="false">+</m:mo><m:msub><m:mi>a</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mn>2k</m:mn></m:mrow></m:mstyle></m:msub></m:mrow><m:msup><m:mi>e</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mrow><m:mo stretchy="false">−</m:mo><m:mi fontstyle="italic">j2ω</m:mi></m:mrow></m:mrow></m:mstyle></m:msup></m:mrow></m:mfrac></m:mrow></m:mrow></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{H \( ω \) = Prod cSub { size 8{k=1} }  cSup { size 8{N rSub { size 6{s} } } }  { {  {b rSub { size 8{0k} } +b rSub { size 8{1k} } e rSup { size 8{ - jω} } +b rSub { size 8{2k} } e rSup { size 8{ - j2ω} } }  over  {1+a rSub { size 8{1k} } e rSup { size 8{ - jω} } +a rSub { size 8{2k} } e rSup { size 8{ - j2ω} } } } } } {}</m:annotation></m:semantics></m:math>  </equation><para id="id44020474">where 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:msub><m:mi>N</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mi>s</m:mi></m:mrow></m:mstyle></m:msub><m:mo stretchy="false">=</m:mo><m:mfenced open="⌊" close="⌋"><m:mrow><m:mi>N</m:mi><m:mo stretchy="false">/</m:mo><m:mn>2</m:mn></m:mrow></m:mfenced></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{N rSub { size 8{s} } = left lfloor N/2 right rfloor } {}</m:annotation></m:semantics></m:math> and 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mfenced open="⌊" close="⌋"><m:mtext>.</m:mtext></m:mfenced></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{ left lfloor  "."  right rfloor } {}</m:annotation></m:semantics></m:math> represents the largest integer less than or equal to the argument. This serial or cascaded structure is illustrated in <link target-id="id44020658"/>.</para>
      <para id="id44020651">
        <figure id="id44020658"><media id="id8499396" alt=""><image src="../../media/graphics17-0c48.png" mime-type="image/png" height="53" width="523"/></media><caption>Cascaded Filter Stages</caption></figure>
      </para>
      
      <para id="id44020696">Each second-order filter is considered to be of direct-form II, shown in <link target-id="id44020731"/>, for its memory efficiency. One can implement each second-order filter in software. Normally, digital filters are implemented in software, but one can also implement them in hardware by using digital circuit adders and shifters. </para>
      <para id="id44020716">
        <figure id="id44020731"><media id="id8499457" alt=""><image src="../../media/graphics18-a700.png" mime-type="image/png" height="242" width="428"/></media><caption>Second Order Direct-Form II</caption></figure>
      </para>
      
      
      
    </section>
  </content>


</document>