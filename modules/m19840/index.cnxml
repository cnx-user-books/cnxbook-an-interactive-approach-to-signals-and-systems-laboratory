<document xmlns="http://cnx.rice.edu/cnxml" xmlns:m="http://www.w3.org/1998/Math/MathML">
  <title>Lab 3: Convolution and Its Applications</title>
  <metadata xmlns:md="http://cnx.rice.edu/mdml">
  <md:content-id>m19840</md:content-id>
  <md:title>Lab 3: Convolution and Its Applications</md:title>
  <md:abstract/>
  <md:uuid>50245a3a-ecbd-4659-92e0-aa53cc8c3845</md:uuid>
</metadata>

<content>
    <para id="id19801073">This lab involves experimenting with the convolution of two continuous-time signals. The main mathematical part is written as a .m file, which is then used as a LabVIEW MathScript node within the LabVIEW programming environment to gain user interactivity. Due to the discrete-time nature of programming, an approximation of the convolution integral is needed. As an application of the convolution concept, echoes are removed from speech recordings using this concept. </para>
    <section id="id22245807">
      
        <title>Numerical Approximation of Convolution</title>
        <para id="id9597902">In this section, let us apply the LabVIEW MathScript function <code display="inline">conv</code> to compute the convolution of two signals. One can choose various values of the time interval
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mi>Δ</m:mi></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{Δ} {}</m:annotation></m:semantics></m:math> to compute numerical approximations to the convolution integral. </para>
      
    

    <section id="id19673392">
     
        <title>Convolution Example 1</title>
        <para id="id17570631">In this example, use the function conv to compute the convolution of the signals 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>x</m:mi><m:mo stretchy="false">(</m:mo><m:mi>t</m:mi><m:mrow><m:mo stretchy="false">)</m:mo><m:mo stretchy="false">=</m:mo><m:mtext>exp</m:mtext></m:mrow><m:mrow><m:mo stretchy="false">(</m:mo><m:mo stretchy="false">−</m:mo><m:mstyle fontstyle="italic"><m:mrow><m:mtext>at</m:mtext></m:mrow></m:mstyle></m:mrow><m:mo stretchy="false">)</m:mo><m:mi>u</m:mi><m:mo stretchy="false">(</m:mo><m:mi>t</m:mi><m:mo stretchy="false">)</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{x \( t \) ="exp" \(  -  ital "at" \) u \( t \) } {}</m:annotation></m:semantics></m:math> and 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>h</m:mi><m:mo stretchy="false">(</m:mo><m:mi>t</m:mi><m:mrow><m:mo stretchy="false">)</m:mo><m:mo stretchy="false">=</m:mo><m:mtext>exp</m:mtext></m:mrow><m:mrow><m:mo stretchy="false">(</m:mo><m:mo stretchy="false">−</m:mo><m:mstyle fontstyle="italic"><m:mrow><m:mtext>bt</m:mtext></m:mrow></m:mstyle></m:mrow><m:mo stretchy="false">)</m:mo><m:mi>u</m:mi><m:mo stretchy="false">(</m:mo><m:mi>t</m:mi><m:mo stretchy="false">)</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{h \( t \) ="exp" \(  -  ital "bt" \) u \( t \) } {}</m:annotation></m:semantics></m:math>with
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>u</m:mi><m:mo stretchy="false">(</m:mo><m:mi>t</m:mi><m:mo stretchy="false">)</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{u \( t \) } {}</m:annotation></m:semantics></m:math>representing a step function starting at 0 for
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mrow><m:mn>0</m:mn><m:mo stretchy="false">≤</m:mo><m:mi>t</m:mi></m:mrow><m:mo stretchy="false">≤</m:mo><m:mn>8</m:mn></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{0 &lt;= t &lt;= 8} {}</m:annotation></m:semantics></m:math>. Consider the following values of the approximation pulse width or delta: 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mrow><m:mi>Δ</m:mi><m:mo stretchy="false">=</m:mo><m:mn>0</m:mn></m:mrow><m:mtext>.</m:mtext><m:mn>5,</m:mn><m:mi/><m:mn>0</m:mn><m:mtext>.</m:mtext><m:mn>1,</m:mn><m:mi/><m:mn>0</m:mn><m:mtext>.</m:mtext><m:mtext>05</m:mtext><m:mi>,</m:mi><m:mi/><m:mn>0</m:mn><m:mtext>.</m:mtext><m:mtext>01</m:mtext><m:mi>,</m:mi><m:mi/><m:mn>0</m:mn><m:mtext>.</m:mtext><m:mtext>005</m:mtext><m:mi>,</m:mi><m:mi/><m:mn>0</m:mn><m:mtext>.</m:mtext><m:mtext>001</m:mtext></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{Δ=0 "." 5,`0 "." 1,`0 "." "05",`0 "." "01",`0 "." "005",`0 "." "001"} {}</m:annotation></m:semantics></m:math>. Mathematically, the convolution of 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>h</m:mi><m:mo stretchy="false">(</m:mo><m:mi>t</m:mi><m:mo stretchy="false">)</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{h \( t \) } {}</m:annotation></m:semantics></m:math>and 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>x</m:mi><m:mo stretchy="false">(</m:mo><m:mi>t</m:mi><m:mo stretchy="false">)</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{x \( t \) } {}</m:annotation></m:semantics></m:math>is given by</para>
        
        <equation id="eip-421"><m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>y</m:mi><m:mo stretchy="false">(</m:mo><m:mi>t</m:mi><m:mrow><m:mo stretchy="false">)</m:mo><m:mo stretchy="false">=</m:mo><m:mfrac><m:mn>1</m:mn><m:mrow><m:mi>a</m:mi><m:mo stretchy="false">−</m:mo><m:mi>b</m:mi></m:mrow></m:mfrac></m:mrow><m:mo stretchy="false">(</m:mo><m:mrow><m:msup><m:mi>e</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mrow><m:mo stretchy="false">−</m:mo><m:mstyle fontstyle="italic"><m:mrow><m:mtext>bt</m:mtext></m:mrow></m:mstyle></m:mrow></m:mrow></m:mstyle></m:msup><m:mo stretchy="false">−</m:mo><m:msup><m:mi>e</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mrow><m:mo stretchy="false">−</m:mo><m:mstyle fontstyle="italic"><m:mrow><m:mtext>at</m:mtext></m:mrow></m:mstyle></m:mrow></m:mrow></m:mstyle></m:msup></m:mrow><m:mo stretchy="false">)</m:mo><m:mi>u</m:mi><m:mo stretchy="false">(</m:mo><m:mi>t</m:mi><m:mo stretchy="false">)</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{y \( t \) = {  {1}  over  {a - b} }  \( e rSup { size 8{ -  ital "bt"} }  - e rSup { size 8{ -  ital "at"} }  \) u \( t \) } {}</m:annotation></m:semantics></m:math>  </equation><para id="id20158312">Compare the approximation 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mover accent="true"><m:mi>y</m:mi><m:mo stretchy="false">ˆ</m:mo></m:mover><m:mo stretchy="false">(</m:mo><m:mi fontstyle="italic">nΔ</m:mi><m:mo stretchy="false">)</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{ { hat  {y}} \( nΔ \) } {}</m:annotation></m:semantics></m:math>obtained via the function <code display="inline">conv</code> with the theoretical value 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>y</m:mi><m:mo stretchy="false">(</m:mo><m:mi>t</m:mi><m:mo stretchy="false">)</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{y \( t \) } {}</m:annotation></m:semantics></m:math>given by Equation (1). To better see the difference between the approximated 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mover accent="true"><m:mi>y</m:mi><m:mo stretchy="false">ˆ</m:mo></m:mover><m:mo stretchy="false">(</m:mo><m:mi fontstyle="italic">nΔ</m:mi><m:mo stretchy="false">)</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{ { hat  {y}} \( nΔ \) } {}</m:annotation></m:semantics></m:math>and the true 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mover accent="true"><m:mi>y</m:mi><m:mo stretchy="false">ˆ</m:mo></m:mover><m:mo stretchy="false">(</m:mo><m:mi fontstyle="italic">nΔ</m:mi><m:mo stretchy="false">)</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{ { hat  {y}} \( nΔ \) } {}</m:annotation></m:semantics></m:math>values, display
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mover accent="true"><m:mi>y</m:mi><m:mo stretchy="false">ˆ</m:mo></m:mover><m:mo stretchy="false">(</m:mo><m:mi>t</m:mi><m:mo stretchy="false">)</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{ { hat  {y}} \( t \) } {}</m:annotation></m:semantics></m:math>and 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>y</m:mi><m:mo stretchy="false">(</m:mo><m:mi>t</m:mi><m:mo stretchy="false">)</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{y \( t \) } {}</m:annotation></m:semantics></m:math> in the same graph.</para>
        <para id="id22143686">Compute the mean squared error (MSE) between the true and approximated values using the following equation:</para>
        
        <equation id="eip-75"><m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mrow><m:mstyle fontstyle="italic"><m:mrow><m:mtext>MSE</m:mtext></m:mrow></m:mstyle><m:mo stretchy="false">=</m:mo><m:mfrac><m:mn>1</m:mn><m:mi>N</m:mi></m:mfrac></m:mrow><m:mrow><m:munderover><m:mo stretchy="false">∑</m:mo><m:mstyle fontsize="8pt"><m:mrow><m:mrow><m:mi>n</m:mi><m:mo stretchy="false">=</m:mo><m:mn>1</m:mn></m:mrow></m:mrow></m:mstyle><m:mstyle fontsize="8pt"><m:mrow><m:mi>N</m:mi></m:mrow></m:mstyle></m:munderover><m:mrow><m:mo stretchy="false">(</m:mo><m:mi>y</m:mi><m:mo stretchy="false">(</m:mo><m:mi fontstyle="italic">nΔ</m:mi><m:mrow><m:mo stretchy="false">)</m:mo><m:mo stretchy="false">−</m:mo><m:mover accent="true"><m:mi>y</m:mi><m:mo stretchy="false">ˆ</m:mo></m:mover></m:mrow><m:mo stretchy="false">(</m:mo><m:mi fontstyle="italic">nΔ</m:mi><m:mo stretchy="false">)</m:mo><m:msup><m:mo stretchy="false">)</m:mo><m:mstyle fontsize="8pt"><m:mrow><m:mn>2</m:mn></m:mrow></m:mstyle></m:msup></m:mrow></m:mrow></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{ ital "MSE"= {  {1}  over  {N} }  Sum cSub { size 8{n=1} }  cSup { size 8{N} }  { \( y \( nΔ \)  -  { hat  {y}} \( nΔ \)  \)  rSup { size 8{2} } } } {}</m:annotation></m:semantics></m:math>  </equation><para id="id21951664">where
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>N</m:mi><m:mo stretchy="false">=</m:mo><m:mfenced open="⌊" close="⌋"><m:mfrac><m:mi>T</m:mi><m:mi>Δ</m:mi></m:mfrac></m:mfenced></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{N= left lfloor  {  {T}  over  {Δ} }  right rfloor } {}</m:annotation></m:semantics></m:math>, T is an adjustable time duration expressed in seconds and the symbol 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mfenced open="⌊" close="⌋"><m:mtext>.</m:mtext></m:mfenced></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{ left lfloor  "."  right rfloor } {}</m:annotation></m:semantics></m:math> denotes the nearest integer. To begin with, set
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>T</m:mi><m:mo stretchy="false">=</m:mo><m:mn>8</m:mn></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{T=8} {}</m:annotation></m:semantics></m:math>.</para>
        <para id="id14004661">As you can see here, the main program is written as a .m file and placed inside LabVIEW as a LabVIEW MathScript node by invoking <emphasis>Functions </emphasis><emphasis>→</emphasis><emphasis> Programming </emphasis><emphasis>→</emphasis><emphasis>Structures </emphasis><emphasis>→</emphasis><emphasis> MathScript</emphasis>. The .m file can be typed in or copied and pasted into the LabVIEW MathScript node. The inputs to this program consist of an approximation pulse width
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mi>Δ</m:mi></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{Δ} {}</m:annotation></m:semantics></m:math>, input exponent powers 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mi>a</m:mi></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{a} {}</m:annotation></m:semantics></m:math>and 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mi>b</m:mi></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{b} {}</m:annotation></m:semantics></m:math> and a desired time duration 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mi>T</m:mi></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{T} {}</m:annotation></m:semantics></m:math>. To add these inputs, right-click on the border of the LabVIEW MathScript node and click on the <term>Add Input</term> option as shown in <link target-id="id21038611"/>. </para>
        <figure id="id21038611"><media id="id17869250" alt=""><image src="../../media/figure 3-3.png" mime-type="image/png" height="404" width="588"/></media><caption>(a) Adding Inputs, (b) Creating Controls</caption></figure><para id="id21415278">After adding these inputs, create controls to allow one to alter the inputs interactively via the front panel. By right-clicking on the border, add the outputs in a similar manner. An important consideration is the selection of the output data type. Set the outputs to consist of MSE, actual or true convolution output y_ac and approximated convolution output y. The first output is a scalar quantity while the other two are one-dimensional vectors. The output data types should be specified by right-clicking on the outputs and selecting the <term>Choose Data Type</term> option (see <link target-id="id19793625"/>).</para>
        <figure id="id19793625"><media id="id20400136" alt=""><image src="../../media/graphics2-77fc.png" mime-type="image/png" height="698" width="475"/></media><caption>(a) Adding Outputs, (b) Choosing Data Types</caption></figure>
        
        <para id="id21012105"/>
        <para id="id22048594">Next write the following .m file textual code inside the LabVIEW MathScript node:</para>
        <para id="id21688464">
          <code display="inline">t=0:Delta:8;</code>
        </para>
        <para id="id21678246">
          <code display="inline">Lt=length(t);</code>
        </para>
        <para id="id22778576">
          <code display="inline">x1=exp(-a*t);</code>
        </para>
        <para id="id20519659">
          <code display="inline">x2=exp(-b*t);</code>
        </para>
        <para id="id20021042">
          <code display="inline">y=Delta*conv(x1,x2);</code>
        </para>
        <para id="id22067495">
          <code display="inline">y_ac=1/(a-b)*(exp(-b*t)-exp(-a*t));</code>
        </para>
        <para id="id18931242">
          <code display="inline">MSE=sum((y(1:Lt)-y_ac).^2)/Lt</code>
        </para>
        <para id="id19478998">With this code, a time vector t is generated by taking a time interval of Delta for 8 seconds. Convolve the two input signals, x1 and x2, using the function conv. Compute the actual output y_ac using Equation (1). Measure the length of the time vector and input vectors by using the command length(t). The convolution output vector y has a different size (if two input vectors m and n are convolved, the output vector size is m+n-1). Thus, to keep the size the same, use a portion of the output corresponding to y(1:Lt) during the error calculation. </para>
        <para id="id19372691">Use a waveform graph to show the waveforms. With the function Build Waveform <emphasis>(Functions → Programming → Waveforms → Build Waveforms)</emphasis>, one can show the waveforms across time. Connect the time interval Delta to the input dt of this function to display the waveforms along the time axis (in seconds).</para>
        <para id="id16984387">Merge together and display the true and approximated outputs in the same graph using the function Merge Signal <emphasis>(Functions → Express → Sig Manip  → Merge Signals)</emphasis>. Configure the properties of the waveform graph as shown in <link target-id="id16406787"/>.</para><figure id="id16406787"><media id="id15468372" alt=""><image src="../../media/graphics9-a5b7.png" mime-type="image/png" height="505" width="509"/></media><caption>Waveform Graph Properties Dialog Box</caption></figure>
        
        <para id="id12898347"><link target-id="id20154837"/> illustrates the completed block diagram of the numerical convolution.</para>
        <para id="id9076401">
          <figure id="id20154837"><media id="id6662572" alt=""><image src="../../media/graphics10-f8f3.png" mime-type="image/png" height="441" width="598"/></media><caption>Block Diagram of the Convolution Example</caption></figure>
        </para>
        
        <para id="id22130145"><link target-id="id23243715"/> shows the corresponding front panel, which can be used to change parameters. Adjust the input exponent powers and approximation pulse-width <term>Delta</term> to see the effect on the <term>MSE</term>.</para>
        <para id="id22324410">
          <figure id="id23243715"><media id="id17860863" alt=""><image src="../../media/graphics11-9152.png" mime-type="image/png" height="543" width="592"/></media><caption>Front Panel of the Convolution Example</caption></figure>
        </para>
        
      </section>
    

    <section id="id5395251"><title>Convolution Example 2</title><para id="id5333532">Next, consider the convolution of the two signals 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>x</m:mi><m:mo stretchy="false">(</m:mo><m:mi>t</m:mi><m:mrow><m:mo stretchy="false">)</m:mo><m:mo stretchy="false">=</m:mo><m:mtext>exp</m:mtext></m:mrow><m:mrow><m:mo stretchy="false">(</m:mo><m:mo stretchy="false">−</m:mo><m:mn>2t</m:mn></m:mrow><m:mo stretchy="false">)</m:mo><m:mi>u</m:mi><m:mo stretchy="false">(</m:mo><m:mi>t</m:mi><m:mo stretchy="false">)</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{x \( t \) ="exp" \(  - 2t \) u \( t \) } {}</m:annotation></m:semantics></m:math>and 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>h</m:mi><m:mo stretchy="false">(</m:mo><m:mi>t</m:mi><m:mrow><m:mo stretchy="false">)</m:mo><m:mo stretchy="false">=</m:mo><m:mstyle fontstyle="italic"><m:mrow><m:mtext>rect</m:mtext></m:mrow></m:mstyle></m:mrow><m:mo stretchy="false">(</m:mo><m:mfrac><m:mrow><m:mi>t</m:mi><m:mo stretchy="false">−</m:mo><m:mn>2</m:mn></m:mrow><m:mn>2</m:mn></m:mfrac><m:mo stretchy="false">)</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{h \( t \) = ital "rect" \(  {  {t - 2}  over  {2} }  \) } {}</m:annotation></m:semantics></m:math> for , where 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>u</m:mi><m:mo stretchy="false">(</m:mo><m:mi>t</m:mi><m:mo stretchy="false">)</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{u \( t \) } {}</m:annotation></m:semantics></m:math>denotes a step function at time 0 and <code display="inline">rect</code> a rectangular function defined as</para><equation id="eip-228"><m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mstyle fontstyle="italic"><m:mrow><m:mtext>rect</m:mtext></m:mrow></m:mstyle><m:mo stretchy="false">(</m:mo><m:mi>t</m:mi><m:mrow><m:mo stretchy="false">)</m:mo><m:mo stretchy="false">=</m:mo><m:mrow><m:mo stretchy="true">{</m:mo><m:mtable><m:mtr><m:mtd><m:mrow><m:mn>1</m:mn><m:mrow/></m:mrow></m:mtd><m:mtd><m:mrow><m:mrow><m:mo stretchy="false">−</m:mo><m:mn>0</m:mn></m:mrow><m:mtext>.</m:mtext><m:mrow><m:mrow><m:mn>5</m:mn><m:mo stretchy="false">≤</m:mo><m:mi>t</m:mi></m:mrow><m:mo stretchy="false">&lt;</m:mo><m:mn>0</m:mn></m:mrow><m:mtext>.</m:mtext><m:mn>5</m:mn><m:mrow/></m:mrow></m:mtd></m:mtr><m:mtr><m:mtd><m:mrow><m:mn>0</m:mn><m:mrow/></m:mrow></m:mtd><m:mtd><m:mrow><m:mstyle fontstyle="italic"><m:mrow><m:mtext>otherwise</m:mtext></m:mrow></m:mstyle><m:mrow/></m:mrow></m:mtd></m:mtr></m:mtable></m:mrow></m:mrow></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{ ital "rect" \( t \) = left lbrace  matrix {
1 {} #  - 0 "." 5 &lt;= t&lt;0 "." 5 {} ##
0 {} #  ital "otherwise"{}
}  right none } {}</m:annotation></m:semantics></m:math> </equation><para id="id21343281">Let 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mrow><m:mi>Δ</m:mi><m:mo stretchy="false">=</m:mo><m:mn>0</m:mn></m:mrow><m:mtext>.</m:mtext><m:mtext>01</m:mtext></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{Δ=0 "." "01"} {}</m:annotation></m:semantics></m:math>. <link target-id="id20960724"/> shows the block diagram for this second convolution example. Again, the .m file textual code is placed inside a LabVIEW MathScript node with the appropriate inputs and outputs.</para><para id="id21897027">
	<figure id="id20960724"><media id="id4603914" alt=""><image src="../../media/graphics13-c2e3.png" mime-type="image/png" height="379" width="534"/></media><caption>Block Diagram for the Convolution of Two Signals</caption></figure>
</para><para id="id22233216"/><para id="id21899656"> <link target-id="id19451294"/> illustrates the corresponding front panel where
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>x</m:mi><m:mo stretchy="false">(</m:mo><m:mi>t</m:mi><m:mo stretchy="false">)</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{x \( t \) } {}</m:annotation></m:semantics></m:math>, 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>h</m:mi><m:mo stretchy="false">(</m:mo><m:mi>t</m:mi><m:mo stretchy="false">)</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{h \( t \) } {}</m:annotation></m:semantics></m:math> and 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>x</m:mi><m:mo stretchy="false">(</m:mo><m:mi>t</m:mi><m:mrow><m:mo stretchy="false">)</m:mo><m:mo stretchy="false">∗</m:mo><m:mi>h</m:mi></m:mrow><m:mo stretchy="false">(</m:mo><m:mi>t</m:mi><m:mo stretchy="false">)</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{x \( t \)  * h \( t \) } {}</m:annotation></m:semantics></m:math> are plotted in different graphs. Convolution 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mo stretchy="false">(</m:mo><m:mo stretchy="false">∗</m:mo><m:mo stretchy="false">)</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{ \(  *  \) } {}</m:annotation></m:semantics></m:math> and equal 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mo stretchy="false">(</m:mo><m:mo stretchy="false">=</m:mo><m:mo stretchy="false">)</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{ \( = \) } {}</m:annotation></m:semantics></m:math>signs are placed between the graphs using the LabVIEW function <code display="inline">Decorations</code>. </para><figure id="id19451294"><media id="id15915800" alt=""><image src="../../media/graphics14-e673.png" mime-type="image/png" height="618" width="597"/></media><caption>Front Panel for the Convolution of Two Signals</caption></figure></section>
  
    <section id="id16040463">
    
        <title>Convolution Example 3</title>
        <para id="id21347560">In this third example, compute the convolution of the signals shown in <link target-id="id17816940"/>.</para>
        <figure id="id17816940"><media id="id20792510" alt=""><image src="../../media/graphics15-b7b1.png" mime-type="image/png" height="231" width="737"/></media><caption>Signals x1(t) and x2(t)</caption></figure>
        
        <para id="id19660927"><link target-id="id20680354"/> shows the block diagram for this third convolution example and <link target-id="id21817271"/> the corresponding front panel. The signals
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi fontstyle="italic">x1</m:mi><m:mo stretchy="false">(</m:mo><m:mi>t</m:mi><m:mo stretchy="false">)</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{x1 \( t \) } {}</m:annotation></m:semantics></m:math>, 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi fontstyle="italic">x2</m:mi><m:mo stretchy="false">(</m:mo><m:mi>t</m:mi><m:mo stretchy="false">)</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{x2 \( t \) } {}</m:annotation></m:semantics></m:math> and 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi fontstyle="italic">x1</m:mi><m:mo stretchy="false">(</m:mo><m:mi>t</m:mi><m:mrow><m:mo stretchy="false">)</m:mo><m:mo stretchy="false">∗</m:mo><m:mi fontstyle="italic">x2</m:mi></m:mrow><m:mo stretchy="false">(</m:mo><m:mi>t</m:mi><m:mo stretchy="false">)</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{x1 \( t \)  * x2 \( t \) } {}</m:annotation></m:semantics></m:math> are displayed in different graphs. </para>
        <para id="id21228388">
          <figure id="id20680354"><media id="id20456958" alt=""><image src="../../media/graphics16-3c62.png" mime-type="image/png" height="425" width="523"/></media><caption>Block Diagram for the Convolution of Two Signals</caption></figure>
        </para>
        
        <figure id="id21817271"><media id="id19246270" alt=""><image src="../../media/graphics17-baf3.png" mime-type="image/png" height="568" width="606"/></media><caption>Front Panel for the Convolution of Two Signals</caption></figure>
        
      </section>
    </section>

    <section id="id20520735"><title>Convolution Properties </title><para id="id22499714">In this part, examine the properties of convolution. <link target-id="id19772623"/> shows the block diagram to examine the properties and <link target-id="id22436541"/> and <link target-id="id12716177"/> the corresponding front panel. Both sides of equations are plotted in this front panel to verify the convolution properties. To display different convolution properties within a limited screen area, use a <term>Tab Control </term><emphasis>(Controls </emphasis><emphasis>→</emphasis><emphasis>Modern</emphasis><emphasis>→</emphasis><emphasis>Containers</emphasis><emphasis>→</emphasis><emphasis>Tab Control)</emphasis> in the front panel.</para>

<figure id="id19772623"><media id="id6779304" alt=""><image src="../../media/graphics19.PNG" mime-type="image/png" height="865" width="590"/></media><caption>Front Panel of Convolution Properties</caption></figure>

<figure id="id22436541"><media id="id18317857" alt=""><image src="../../media/graphics18.PNG" mime-type="image/png" height="752" width="593"/></media><caption>Block Diagram of Convolution Properties</caption></figure>

<figure id="id12716177"><media id="id17840106" alt=""><image src="../../media/cov_properties.png" mime-type="image/png" height="749" width="495"/></media><caption>Tabs Showing Convolution Properties</caption></figure>

</section>

    <section id="id14298785">
      
      <title> Linear Circuit Analysis Using Convolution </title><para id="id20158302">In this part, let us consider an application of convolution in analyzing RLC circuits to gain a better understanding of the convolution concept. A linear circuit denotes a linear system, which can be represented with its impulse response
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>h</m:mi><m:mo stretchy="false">(</m:mo><m:mi>t</m:mi><m:mo stretchy="false">)</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{h \( t \) } {}</m:annotation></m:semantics></m:math>, that is, its response to a unit impulse input. The input to such a system can be considered to be a voltage 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>v</m:mi><m:mo stretchy="false">(</m:mo><m:mi>t</m:mi><m:mo stretchy="false">)</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{v \( t \) } {}</m:annotation></m:semantics></m:math>and the output to be the circuit current
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>i</m:mi><m:mo stretchy="false">(</m:mo><m:mi>t</m:mi><m:mo stretchy="false">)</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{i \( t \) } {}</m:annotation></m:semantics></m:math>. See <link target-id="id18255063"/>.</para>
      <figure id="id18255063"><media id="id16140663" alt=""><image src="../../media/graphics23-e7c0.png" mime-type="image/png" height="105" width="322"/></media><caption>Impulse Response Representation of a Linear Circuit</caption></figure>
      
      <para id="id20934116">For a simple RC series circuit shown in <link target-id="id22524540"/>, the impulse response is given by <link target-id="Ref6" document="m31521"/> ,</para>
      
      <equation id="eip-229"><m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>h</m:mi><m:mo stretchy="false">(</m:mo><m:mi>t</m:mi><m:mrow><m:mo stretchy="false">)</m:mo><m:mo stretchy="false">=</m:mo><m:mfrac><m:mn>1</m:mn><m:mi>RC</m:mi></m:mfrac></m:mrow><m:mtext>exp</m:mtext><m:mrow><m:mo stretchy="false">(</m:mo><m:mo stretchy="false">−</m:mo><m:mfrac><m:mn>1</m:mn><m:mstyle fontstyle="italic"><m:mrow><m:mtext>RC</m:mtext></m:mrow></m:mstyle></m:mfrac></m:mrow><m:mi>t</m:mi><m:mo stretchy="false">)</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{h \( t \) = {  {1}  over  {RC} } "exp" \(  -  {  {1}  over  { ital "RC"} } t \) } {}</m:annotation></m:semantics></m:math>
</equation><para id="id11405013">which can be obtained for any specified values of R and C. When an input voltage 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>v</m:mi><m:mo stretchy="false">(</m:mo><m:mi>t</m:mi><m:mo stretchy="false">)</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{v \( t \) } {}</m:annotation></m:semantics></m:math> (either DC or AC) is applied to the system, the circuit current 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>i</m:mi><m:mo stretchy="false">(</m:mo><m:mi>t</m:mi><m:mo stretchy="false">)</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{i \( t \) } {}</m:annotation></m:semantics></m:math> can be obtained by simply convolving the system impulse response with the input voltage, that is</para>
      
      <equation id="eip-598"><m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>i</m:mi><m:mo stretchy="false">(</m:mo><m:mi>t</m:mi><m:mrow><m:mo stretchy="false">)</m:mo><m:mo stretchy="false">=</m:mo><m:mi>h</m:mi></m:mrow><m:mo stretchy="false">(</m:mo><m:mi>t</m:mi><m:mrow><m:mo stretchy="false">)</m:mo><m:mo stretchy="false">∗</m:mo><m:mi>v</m:mi></m:mrow><m:mo stretchy="false">(</m:mo><m:mi>t</m:mi><m:mo stretchy="false">)</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{i \( t \) =h \( t \)  * v \( t \) } {}</m:annotation></m:semantics></m:math>  </equation><figure id="id22524540"><media id="id20879245" alt=""><image src="../../media/graphics24.png" mime-type="image/png" height="142" width="299"/></media><caption>RC Circuit</caption></figure>
      
      <para id="id19772340">Similarly, for the simple RL series circuit shown in <link target-id="id20967289"/>, the impulse response is given by <link target-id="Ref6" document="m31521"/> ,</para>
      
      <equation id="eip-580"><m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>h</m:mi><m:mo stretchy="false">(</m:mo><m:mi>t</m:mi><m:mrow><m:mo stretchy="false">)</m:mo><m:mo stretchy="false">=</m:mo><m:mfrac><m:mn>R</m:mn><m:mi>L</m:mi></m:mfrac></m:mrow><m:mtext>exp</m:mtext><m:mrow><m:mo stretchy="false">(</m:mo><m:mo stretchy="false">−</m:mo><m:mfrac><m:mi>R</m:mi><m:mi>L</m:mi></m:mfrac></m:mrow><m:mi>t</m:mi><m:mo stretchy="false">)</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{h \( t \) = {  {1}  over  {L} } "exp" \(  -  {  {R}  over  {L} } t \) } {}</m:annotation></m:semantics></m:math>
</equation><para id="id21933815">When an input voltage 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>v</m:mi><m:mo stretchy="false">(</m:mo><m:mi>t</m:mi><m:mo stretchy="false">)</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{v \( t \) } {}</m:annotation></m:semantics></m:math> is applied to the system, the circuit current 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>i</m:mi><m:mo stretchy="false">(</m:mo><m:mi>t</m:mi><m:mo stretchy="false">)</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{i \( t \) } {}</m:annotation></m:semantics></m:math> can be obtained by computing the convolution integral.</para>
      <figure id="id20967289"><media id="id3392041" alt=""><image src="../../media/graphics25-924b.png" mime-type="image/png" height="120" width="291"/></media><caption>RL Circuit</caption></figure>
      
      <para id="id20630574"><link target-id="id22013619"/> shows the block diagram of this linear system and <link target-id="id19614445"/> the corresponding front panel. From the front panel, one can control the system type (RL or RC), input voltage type (DC or AC) and input voltage amplitude. One can also observe the system response by changing R, L and C values. Three graphs are used to display the input voltage
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>v</m:mi><m:mo stretchy="false">(</m:mo><m:mi>t</m:mi><m:mo stretchy="false">)</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{v \( t \) } {}</m:annotation></m:semantics></m:math>, impulse response of the circuit 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>h</m:mi><m:mo stretchy="false">(</m:mo><m:mi>t</m:mi><m:mo stretchy="false">)</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{h \( t \) } {}</m:annotation></m:semantics></m:math> and circuit current
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>i</m:mi><m:mo stretchy="false">(</m:mo><m:mi>t</m:mi><m:mo stretchy="false">)</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{i \( t \) } {}</m:annotation></m:semantics></m:math>. </para>
      <para id="id22310965">
        <figure id="id22013619"><media id="id17977039" alt=""><image src="../../media/graphics40-6e80.png" mime-type="image/png" height="571" width="588"/></media><caption>Block Diagram of the Linear Circuit Application</caption></figure>
      </para>
      
      <para id="id18915457">
        <figure id="id19614445"><media id="id15779708" alt=""><image src="../../media/graphics27-6b44.png" mime-type="image/png" height="767" width="571"/></media><caption>Front Panel of the Linear Circuit Application</caption></figure>
      </para>
      
    </section>

    <section id="id21104857"><title>Lab Exercises </title><exercise id="element-2"><problem id="id7232542">
			<para id="id4107154">
				<term>Echo Cancellation</term>
			</para><para id="id17168312">In this exercise, consider the problem of removing an echo from a recording of a speech signal. The LabVIEW MathScript function <code display="inline">sound()</code> or the function <term>Play Waveform</term> in LabVIEW can be used to play back the speech recording. To begin, load the .m file echo_1.wav provided on the book website by using the function <code display="inline">wavread(‘filename’)</code>. This speech file was recorded at the sampling rate of 8 kHz, which can be played back through the computer speakers by typing</para><para id="id22075336">
				<code display="inline">&gt;&gt; sound(y)</code>
			</para><para id="id19856474">You should be able to hear the sound with an echo. If the LabVIEW function <term>Play Waveform</term><emphasis>(Functions </emphasis><emphasis>→</emphasis><emphasis> Programming </emphasis><emphasis>→</emphasis><emphasis> Graphics &amp; Sound </emphasis><emphasis>→</emphasis><emphasis> Sound</emphasis><emphasis>→</emphasis><emphasis> Output</emphasis><emphasis>→</emphasis><emphasis> Play Waveform)</emphasis> is used to play the sound, you first need to build a waveform based on the loaded data and the time interval 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mstyle fontstyle="italic"><m:mrow><m:mtext>dt</m:mtext></m:mrow></m:mstyle><m:mo stretchy="false">=</m:mo><m:mrow><m:mn>1</m:mn><m:mo stretchy="false">/</m:mo><m:mtext>8000</m:mtext></m:mrow></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{ ital "dt"=1/"8000"} {}</m:annotation></m:semantics></m:math> because this speech was recorded using an 8 kHz sampling rate. Connect the waveform to the function <term>Play Waveform</term>.</para><para id="id21423492">An echo is produced when the signal (speech, in this case) is reflected off a non-absorbing surface like a wall. What is heard is the original signal superimposed on the signal reflected off the wall (echo). Because the speech is partially absorbed by the wall, it decreases in amplitude. It is also delayed. The echoed signal can be modeled as 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mstyle fontstyle="italic"><m:mrow><m:mtext>ax</m:mtext></m:mrow></m:mstyle><m:mo stretchy="false">(</m:mo><m:mrow><m:mi>t</m:mi><m:mo stretchy="false">−</m:mo><m:mi>τ</m:mi></m:mrow><m:mo stretchy="false">)</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{ ital "ax" \( t - τ \) } {}</m:annotation></m:semantics></m:math>where 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>a</m:mi><m:mo stretchy="false">&lt;</m:mo><m:mn>1</m:mn></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{a&lt;1} {}</m:annotation></m:semantics></m:math> and 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mi>τ</m:mi></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{τ} {}</m:annotation></m:semantics></m:math> denotes the echo delay. Thus, one can represent the speech signal plus the echoed signal as [7] </para>

			<equation id="id16444982"><m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>y</m:mi><m:mo stretchy="false">(</m:mo><m:mi>t</m:mi><m:mrow><m:mo stretchy="false">)</m:mo><m:mo stretchy="false">=</m:mo><m:mi>x</m:mi></m:mrow><m:mo stretchy="false">(</m:mo><m:mi>t</m:mi><m:mrow><m:mo stretchy="false">)</m:mo><m:mo stretchy="false">+</m:mo><m:mstyle fontstyle="italic"><m:mrow><m:mtext>ax</m:mtext></m:mrow></m:mstyle></m:mrow><m:mo stretchy="false">(</m:mo><m:mrow><m:mi>t</m:mi><m:mo stretchy="false">−</m:mo><m:mi>τ</m:mi></m:mrow><m:mo stretchy="false">)</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{y \( t \) =x \( t \) + ital "ax" \( t - τ \) } {}</m:annotation></m:semantics></m:math>
			</equation>

			<para id="id17443643">What is heard is
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>y</m:mi><m:mo stretchy="false">(</m:mo><m:mi>t</m:mi><m:mo stretchy="false">)</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{y \( t \) } {}</m:annotation></m:semantics></m:math>. In many applications, it is important to recover 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>x</m:mi><m:mo stretchy="false">(</m:mo><m:mi>t</m:mi><m:mo stretchy="false">)</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{x \( t \) } {}</m:annotation></m:semantics></m:math> – the original, echo-free signal – from
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>y</m:mi><m:mo stretchy="false">(</m:mo><m:mi>t</m:mi><m:mo stretchy="false">)</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{y \( t \) } {}</m:annotation></m:semantics></m:math>. </para><para id="id21293381">Method 1</para><para id="id22145231">In this method, remove the echo using deconvolution. Rewrite Equation (7) as follows [7]: </para>

<equation id="id23347342"><m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>y</m:mi><m:mo stretchy="false">[</m:mo><m:mi fontstyle="italic">nΔ</m:mi><m:mrow><m:mo stretchy="false">]</m:mo><m:mo stretchy="false">=</m:mo><m:mi>x</m:mi></m:mrow><m:mo stretchy="false">[</m:mo><m:mi fontstyle="italic">nΔ</m:mi><m:mrow><m:mo stretchy="false">]</m:mo><m:mo stretchy="false">+</m:mo><m:mstyle fontstyle="italic"><m:mrow><m:mtext>ax</m:mtext></m:mrow></m:mstyle></m:mrow><m:mo stretchy="false">[</m:mo><m:mo stretchy="false">(</m:mo><m:mrow><m:mi>n</m:mi><m:mo stretchy="false">−</m:mo><m:mi>N</m:mi></m:mrow><m:mo stretchy="false">)</m:mo><m:mi>Δ</m:mi><m:mrow><m:mo stretchy="false">]</m:mo><m:mo stretchy="false">=</m:mo><m:mi>x</m:mi></m:mrow><m:mo stretchy="false">[</m:mo><m:mi fontstyle="italic">nΔ</m:mi><m:mrow><m:mo stretchy="false">]</m:mo><m:mo stretchy="false">∗</m:mo><m:mo stretchy="false">(</m:mo></m:mrow><m:mi>δ</m:mi><m:mo stretchy="false">[</m:mo><m:mi fontstyle="italic">nΔ</m:mi><m:mrow><m:mo stretchy="false">]</m:mo><m:mo stretchy="false">+</m:mo><m:mi fontstyle="italic">aδ</m:mi></m:mrow><m:mo stretchy="false">[</m:mo><m:mrow><m:mi>n</m:mi><m:mo stretchy="false">−</m:mo><m:mi>N</m:mi></m:mrow><m:mo stretchy="false">]</m:mo><m:mi>Δ</m:mi><m:mrow><m:mo stretchy="false">)</m:mo><m:mo stretchy="false">=</m:mo><m:mi>x</m:mi></m:mrow><m:mo stretchy="false">[</m:mo><m:mi fontstyle="italic">nΔ</m:mi><m:mrow><m:mo stretchy="false">]</m:mo><m:mo stretchy="false">∗</m:mo><m:mi>h</m:mi></m:mrow><m:mo stretchy="false">[</m:mo><m:mi fontstyle="italic">nΔ</m:mi><m:mo stretchy="false">]</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{y \[ nΔ \] =x \[ nΔ \] + ital "ax" \[  \( n - N \) Δ \] =x \[ nΔ \]  *  \( δ \[ nΔ \] +aδ \[ n - N \] Δ \) =x \[ nΔ \]  * h \[ nΔ \] } {}</m:annotation></m:semantics></m:math> </equation>

<para id="id22779544">The echoed signal is the convolution of the original signal 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>x</m:mi><m:mo stretchy="false">(</m:mo><m:mi fontstyle="italic">nΔ</m:mi><m:mo stretchy="false">)</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{x \( nΔ \) } {}</m:annotation></m:semantics></m:math> and the signal 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>h</m:mi><m:mo stretchy="false">(</m:mo><m:mi fontstyle="italic">nΔ</m:mi><m:mo stretchy="false">)</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{h \( nΔ \) } {}</m:annotation></m:semantics></m:math>. Use the LabVIEW MathScript function <code display="inline">deconv(y,h) </code>to recover the original signal. </para><para id="id18782912">Method 2</para><para id="id22736035">An alternative way of removing the echo is to run the echoed signal through the following system:</para>

<equation id="id22193652"><m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>z</m:mi><m:mo stretchy="false">[</m:mo><m:mi fontstyle="italic">nΔ</m:mi><m:mrow><m:mo stretchy="false">]</m:mo><m:mo stretchy="false">=</m:mo><m:mi>y</m:mi></m:mrow><m:mo stretchy="false">[</m:mo><m:mi fontstyle="italic">nΔ</m:mi><m:mrow><m:mo stretchy="false">]</m:mo><m:mo stretchy="false">−</m:mo><m:mstyle fontstyle="italic"><m:mrow><m:mtext>az</m:mtext></m:mrow></m:mstyle></m:mrow><m:mo stretchy="false">[</m:mo><m:mo stretchy="false">(</m:mo><m:mrow><m:mi>n</m:mi><m:mo stretchy="false">−</m:mo><m:mi>N</m:mi></m:mrow><m:mo stretchy="false">)</m:mo><m:mi>Δ</m:mi><m:mo stretchy="false">]</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{z \[ nΔ \] =y \[ nΔ \]  -  ital "az" \[  \( n - N \) Δ \] } {}</m:annotation></m:semantics></m:math> </equation>

<para id="id20746918">Assume that 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>z</m:mi><m:mo stretchy="false">[</m:mo><m:mi fontstyle="italic">nΔ</m:mi><m:mrow><m:mo stretchy="false">]</m:mo><m:mo stretchy="false">=</m:mo><m:mn>0</m:mn></m:mrow></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{z \[ nΔ \] =0} {}</m:annotation></m:semantics></m:math>for
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mi>n</m:mi><m:mo stretchy="false">&lt;</m:mo><m:mn>0</m:mn></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{n&lt;0} {}</m:annotation></m:semantics></m:math>. Implement the above system for different values of 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mi>a</m:mi></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{a} {}</m:annotation></m:semantics></m:math> and
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mi>N</m:mi></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{N} {}</m:annotation></m:semantics></m:math>.</para><para id="id19896666">Display and play back the echoed signal and the echo-free signal using both of the above methods. Specify the parameters 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mi>a</m:mi></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{a} {}</m:annotation></m:semantics></m:math>and 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mi>N</m:mi></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{N} {}</m:annotation></m:semantics></m:math>as controls. Try to measure the proper values of 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mi>a</m:mi></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{a} {}</m:annotation></m:semantics></m:math>and 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mi>N</m:mi></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{N} {}</m:annotation></m:semantics></m:math>by the autocorrelation method described below.</para><para id="id21957888"> The autocorrelation of a signal can be described by the convolution of a signal with its mirror. That is,</para>

<equation id="id23359122"><m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:msub><m:mi>R</m:mi><m:mstyle fontsize="8pt"><m:mrow><m:mstyle fontstyle="italic"><m:mrow><m:mtext>xx</m:mtext></m:mrow></m:mstyle></m:mrow></m:mstyle></m:msub><m:mo stretchy="false">[</m:mo><m:mi>n</m:mi><m:mrow><m:mo stretchy="false">]</m:mo><m:mo stretchy="false">=</m:mo><m:mi>x</m:mi></m:mrow><m:mo stretchy="false">[</m:mo><m:mi>n</m:mi><m:mrow><m:mo stretchy="false">]</m:mo><m:mo stretchy="false">∗</m:mo><m:mi>x</m:mi></m:mrow><m:mrow><m:mo stretchy="false">[</m:mo><m:mo stretchy="false">−</m:mo><m:mi>n</m:mi></m:mrow><m:mo stretchy="false">]</m:mo></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{R rSub { size 8{ ital "xx"} }  \[ n \] =x \[ n \]  * x \[  - n \] } {}</m:annotation></m:semantics></m:math> </equation>

<para id="id18503292">Use the autocorrelation of the output signal (echo-free signal) to estimate the delay time (
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mi>N</m:mi></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{N} {}</m:annotation></m:semantics></m:math>) and the amplitude of the echo (
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mi>a</m:mi></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{a} {}</m:annotation></m:semantics></m:math>). For different values of 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mi>N</m:mi></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{N} {}</m:annotation></m:semantics></m:math>and
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mi>a</m:mi></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{a} {}</m:annotation></m:semantics></m:math>, observe the autocorrelation output. To have an echo-free signal, the side lobes of the autocorrelation should be quite low, as shown in <link target-id="id22052762"/>.</para><figure id="id22052762"><media id="id18525093" alt=""><image src="../../media/graphics28-1a8a.png" mime-type="image/png" height="387" width="554"/></media><caption>Autocorrelation Function of a Signal: (a) Echo Is Not Removed Completely; (b) Echo Is Removed</caption></figure><para id="id20983942"> <link target-id="id7731454"/> shows a typical front panel for this exercise. It is not necessary to obtain the same front panel but there should be controls for 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mi>a</m:mi></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{a} {}</m:annotation></m:semantics></m:math> and 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mi>N</m:mi></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{N} {}</m:annotation></m:semantics></m:math> as well as graphs to observe the echoed signal, echo-free signal and autocorrelation function of the echo-free signal.</para><figure id="id7731454"><media id="id19247609" alt=""><image src="../../media/graphics29-a1d6.png" mime-type="image/png" height="494" width="714"/></media><caption>Front Panel for the Echo Cancellation System</caption></figure>
		</problem>
		<solution id="id8187844">
			<para id="element-287">
    Insert Solution Text Here
  </para>
		</solution>
	</exercise><exercise id="element-356"><problem id="id3391762">
			<para id="id16318078"><term> Noise Reduction Using Mean Filtering </term></para><para id="id15421478">The idea of mean filtering is simply to replace each value in a signal with the mean (average) value of its neighbors. A mean filter is widely used for noise reduction. </para><para id="id18249668"> Start by adding some random noise to a signal (use the file echo_1.wav or any other speech data file). Then, use mean filtering to reduce the introduced noise. More specifically, take the following steps:</para><list id="id18712575" list-type="enumerated">
				<item>Normalize the signal values in the range [0 1].</item>
				<item>Add random noise to the signal by using the function <code display="inline">randn</code>. Set the noise level as a control.</item>
				<item>Convolve the noise-added signal with a mean filter. This filter can be designed by taking an odd number of ones and dividing by the size. For example, a 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mn>1</m:mn><m:mo stretchy="false">×</m:mo><m:mn>3</m:mn></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{1 times 3} {}</m:annotation></m:semantics></m:math> size mean filter is given by [1/3 1/3 1/3] and a 
<m:math><m:semantics><m:mrow><m:mstyle fontsize="12pt"><m:mrow><m:mrow><m:mn>1</m:mn><m:mo stretchy="false">×</m:mo><m:mn>5</m:mn></m:mrow></m:mrow></m:mstyle><m:mrow/></m:mrow><m:annotation encoding="StarMath 5.0"> size 12{1 times 5} {}</m:annotation></m:semantics></m:math>size mean filter by [1/5 1/5 1/5 1/5 1/5]. Set the size of the mean filter as an odd number control (3, 5 or 7, for example).</item>
			</list>
		</problem>
		<solution id="id17574361">
			<para id="element-748">
    Insert Solution Text Here
  </para>
		</solution>
	</exercise>
	<exercise id="element-702"><problem id="id20514974">
			<para id="id16449686">
				<term> Impulse Noise Reduction Using Median Filtering </term>
			</para><para id="id7873457">A median filter is a non-linear filter that replaces a data value with the median of the values within a neighboring window. For example, the median value for this data stream [2 5 3 11 4] is 4. This type of filter is often used to remove impulse noise. Use the file echo_1.wav or any other speech data file and take the following steps: </para><list id="id22503960" list-type="enumerated">
				<item>Normalize the signal values in the range [0 1].</item>
				<item>Randomly add impulse noise to the signal by using the LabVIEW MathScript function <code display="inline">randperm</code>. Set the noise density as a control.</item>
				<item>Find the median values of neighboring data using the function <code display="inline">median</code> and replace the original value with the median value. Set the number of neighboring values as an odd number control (3, 5 or 7, for example).</item>
			</list>
		</problem>
		<solution id="id19038375">
			<para id="element-876">
    Insert Solution Text Here
  </para>
		</solution>
	</exercise>
</section>
  </content>








</document>